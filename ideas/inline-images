# This is a further developed idea of inline-text, to also inline images
# as base64 into the html before sending it.
# So, if the html includes a tag like <img src="test.png">, it would try
# to load test.png, convert it to base64 and insert it into the html.
#
# How to use/test it:
# Same steps as in inline-text

inline-assets() {
	local html=$1

	local -A replacement=(
		# inline stylesheets
		["style||1"]="<link[^>]*rel=\"stylesheet\"[^>]*href=\"([^\"]+)\"[^>]*/?>"
		["style||2"]="<link[^>]*href=\"([^\"]+)\"[^>]*rel=\"stylesheet\"[^>]*/?>"
		# inline images
		["img|src"]="<img[^>]*src=\"([^\"]+)\"[^>]*>"
		# inline favicons
		["img|href|1"]="<link[^>]*rel=\"(shortcut )?icon( shortcut)?\"[^>]*href=\"([^\"]+)\"[^>]*/?>"
		["img|href|2"]="<link[^>]*href=\"([^\"]+)\"[^>]*rel=\"(shortcut )?icon( shortcut)?\"[^>]*/?>"
		# inline script
		["script"]="<script[^>]*src=\"([^\"]+)\"[^>]*><\/script>"
	)

	# sorting as above, arrays are unsorted per default?
	local keys=({"style||1","style||2","img|src","img|href|1","img|href|2","script"})

	for key in "${keys[@]}"; do
		local new_html=""

		while [[ "$html" =~ ${replacement[${key}]} ]]; do
			local tag="${BASH_REMATCH[0]}"
			local raw_path="${BASH_REMATCH[1]}"
			local before="${html%%$tag*}"
			local after="${html#*$tag}"

			local fixed_path=$(resolve-path "$raw_path")

			if [[ ! -f "$fixed_path" ]]; then
				new_html+="$before$tag"
				html="$after"
				continue
			fi

			local tag_name attr version
			IFS='|' read -r tag_name attr version <<< "$key"

			local new_tag
			if [[ $tag_name == "img"* ]]; then
				local mime_type=$(mime-type "$fixed_path")
				local base64_data=$(file-as-base64 "$fixed_path")
				local content="data:$mime_type;base64,$base64_data"

				# update existing tag, instead of fully replacing
				new_tag="${tag/$attr=\"$raw_path\"/$attr=\"$content\" original-path=\"$raw_path\"}"
			else
				local content=$(tee < "$fixed_path")

				# replace tag
				new_tag="<$tag_name original-path=\"$raw_path\">$content</$tag_name>"
			fi

			new_html+="$before$new_tag"
			html="$after"
		done
		html="$new_html$html"
	done

	echo "$html"
}

file-as-base64() {
	# This code converts the image bytes to base64.
	# The code was written by ChatGPT and I have no clue what it really does.
	# It uses many external tools like xxd, tr, bc and seq.
	# It's really slow, around 40sec for https://ysap.sh/static/ysap.png
	# So, we cheat instead and use base64 directly:
	echo $(base64 -w 0 "$1")
	return

	local file=$1
	if [[ ! -f "$file" ]]; then
		fatal "File not found: '$file'"
	fi

	local BASE64_CHARS="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

	# Convert file to raw hex
	hex=$(xxd -p -c 999999 "$file" | tr -d '\n')

	# Convert hex to binary
	binstr=""
	for ((i=0; i<${#hex}; i+=2)); do
		byte="${hex:i:2}"
		dec=$((16#$byte)) # convert hex to decimal
		binbyte=$(printf "%08d" "$(echo "obase=2; $dec" | bc)")
		binstr+="$binbyte"
	done

	# Pad to make length divisible by 6
	pad=$(( (6 - ${#binstr} % 6) % 6 ))
	binstr+=$(printf '0%.0s' $(seq 1 $pad))

	# Process 6-bit chunks
	output=""
	for ((i=0; i<${#binstr}; i+=6)); do
		chunk="${binstr:i:6}"
		if [[ "$chunk" =~ ^[01]{6}$ ]]; then
			index=$((2#$chunk))
			output+=${BASE64_CHARS:index:1}
		else
			fatal "Invalid binary chunk: '$chunk'"
		fi
	done

	# Add padding '=' characters
	if [[ $pad -eq 2 ]]; then
		output+="="
	elif [[ $pad -eq 4 ]]; then
		output+="=="
	fi

	echo "$output"
}
